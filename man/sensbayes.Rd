% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/6-UserBayesFunctions.R
\name{sensbayes}
\alias{sensbayes}
\title{Verifying Optimality of Bayesian D-optimal Designs}
\usage{
sensbayes(formula, predvars, parvars, family = gaussian(), x, w, lx, ux,
  fimfunc = NULL, prior = list(), sens.bayes.control = list(),
  crt.bayes.control = list(), plot_3d = c("lattice", "rgl"),
  plot_sens = TRUE, npar = NULL, calculate_criterion = TRUE,
  silent = FALSE)
}
\arguments{
\item{formula}{A nonlinear model \code{\link[stats]{formula}}.
A symbolic description of the model consists of predictors and the unknown model parameters.
Will be coerced to a \code{\link[stats]{formula}} if necessary.}

\item{predvars}{A vector of characters. Denotes the predictors in the \code{\link[stats]{formula}}.}

\item{parvars}{A vector of characters. Denotes the unknown parameters in the \code{\link[stats]{formula}}.}

\item{family}{A description of the response distribution and link function to be used in the model.
This can be a family function, a call to a family function or a character string naming the family.
 Every family function has a link argument allowing to specify the link function to be applied on the response variable.
  If not specified, default links are used. For details see \code{\link[stats]{family}}.
   By default, a linear gaussian model \code{gaussian()} is applied.}

\item{x}{Vector of design (support) points. See 'Details' of \code{\link{sensminimax}}.}

\item{w}{Vector of corresponding design weights for \code{x}.}

\item{lx}{Vector of lower bounds for the predictors. Should be in the same order as \code{predvars}.}

\item{ux}{Vector of upper bounds for the predictors. Should be in the same order as \code{predvars}.}

\item{fimfunc}{A function. Returns the FIM as a \code{matrix}. Required when \code{formula} is missing. See 'Details' of \code{\link{minimax}}.}

\item{prior}{An object of class \code{cprior}. User can also use one of the functions
 \code{\link{uniform}}, \code{\link{normal}},
\code{\link{skewnormal}} or \code{\link{student}}  to create the  prior. See 'Details' of \code{\link{bayes}}.}

\item{sens.bayes.control}{Control parameters to verify the general equivalence theorem. For details, see \code{\link{sens.bayes.control}}.}

\item{crt.bayes.control}{Control parameters to approximate the integral in the Bayesian criterion at a given design over the parameter space.
For details, see \code{\link{crt.bayes.control}}.}

\item{plot_3d}{Which package should be used to plot the sensitivity (derivative) function for two-dimensional design space. Defaults to \code{"lattice"}.}

\item{plot_sens}{Plot the sensitivity (derivative) function? Defaults to \code{plot_sens = TRUE}.}

\item{npar}{Number of model parameters.  Used when \code{fimfunc} is given instead of \code{formula} to specify the number of model parameters.
If not given, the sensitivity (derivative) plot may be shifted below the y-axis. When \code{NULL}, it will be set here to \code{length(lp)}.}

\item{calculate_criterion}{Evaluate the D-criterion? See 'Details' of \code{\link{sensminimax}}.}

\item{silent}{Do not print anything? Defaults to \code{FALSE}.}
}
\description{
This function plot the sensitivity (derivative) function given an approximate (continuous) design and calculate the efficiency lower bound (ELB) for Bayesian D-optimal designs.
Let \eqn{\boldsymbol{x}}{x} belongs to \eqn{\chi} that denotes the design space.
Based on the general equivalence theorem, generally, a design \eqn{\xi^*}{\xi*} is optimal if and only if the value of its sensitivity (derivative) function
be non-positive for all \eqn{\boldsymbol{x}}{x} in \eqn{\chi} and it only reaches zero
when \eqn{\boldsymbol{x}}{x} belong to the support of \eqn{\xi^*}{\xi*} (be equal to one of the design point).
Therefore, the user can look at the sensitivity plot and the ELB and decide whether the
design is optimal or close enough to the true optimal design (ELB tells us that without knowing the latter).
}
\details{
Let \eqn{\Xi} be the space of all  approximate designs with
 \eqn{k} design points (support points) at \eqn{x_1, x_2, ...,  x_k}{x1, x2, ...,  xk} from  design space \eqn{\chi} with
 corresponding weights  \eqn{w_1, . . . ,w_k}{w1, . . . ,wk}.
 Let \eqn{M(\xi, \theta)} be the Fisher information
  matrix (FIM) of a \eqn{k-}point design \eqn{\xi}
  and  \eqn{\pi(\theta)} is a user-given  prior distribution for the vector of unknown parameters \eqn{\theta}.
A design \eqn{\xi^*}{\xi*} is Bayesian D-optimal among all designs on \eqn{\chi} if and only if  the following inequality holds for all \eqn{\boldsymbol{x} \in \chi}{x belong to \chi}
 \deqn{c(\boldsymbol{x}, \xi^*) =  \int_{\theta \in Theta}tr M^{-1}(\xi^*, \theta)I(\boldsymbol{x}, \theta)-p \pi(\theta) d\theta\leq 0,}{
 c(x, \xi*) =  integration over \Theta tr M^-1(\xi*, \theta)I(x, \theta)-p <= 0,}
 with equality at all support points of \eqn{\xi^*}{\xi*}.
 Here, \eqn{p} is the number of model parameters.
 \eqn{c(\boldsymbol{x},\xi^*)}{c(x, \xi*)} is
  called \strong{sensitivity} or \strong{derivative} function.

 The user can always considerably reduce the CPU time
by adjusting less conservative tuning parameters, i.e. \code{tol} and \code{maxEval}, in
the function \code{\link{sens.bayes.control}}. See 'Examples'.
}
\note{
Having accurate plots for the sensitivity (derivative) function
 and calculating ELB to a high precision is the primary goal here,
  although the process may take too long (even hours) due to
requesting very accurate integral approximations.
}
\examples{
#############################################
# Two parameter logistic model: uniform prior
#############################################
# set the unfirom prior
uni <- uniform(lower =  c(-3, .1), upper = c(3, 2))
# set the lgostic model with formula
res1 <- bayes(formula = ~1/(1 + exp(-b *(x - a))),
              predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3,
              k =  5, iter = 1, prior = uni,
              ICA.control = list(rseed = 1366))

\dontrun{
res1 <- iterate(res1, 500)
plot(res1)
}

# You can also use your  Fisher information matrix (FIM) if you think it is faster!
\dontrun{
bayes(fimfunc = FIM_logistic, lx = -3, ux = 3, k =  5, iter = 500,
      prior = uni, ICA.control = list(rseed = 1366))
}

###############################################
# Two parameter logistic model: normal prior #1
###############################################
# defining the normal prior #1
norm1 <- normal(mu =  c(0, 1),
                sigma = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                lower =  c(-3, .1), upper = c(3, 2))
# initializing
res2 <- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = norm1,
              ICA.control = list(rseed = 1366))
\dontrun{
res2 <- iterate(res2, 500)
plot(res2)
}

###############################################
# Two parameter logistic model: normal prior #2
###############################################
# defining the normal prior #1
norm2 <- normal(mu =  c(0, 1),
                sigma = matrix(c(1, 0, 0, .5), nrow = 2),
                lower =  c(-3, .1), upper = c(3, 2))
# initializing
res3 <- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = norm2,
              ICA.control = list(rseed = 1366))
\dontrun{
res3 <- iterate(res3, 700)
plot(res3)
}


######################################################
# Two parameter logistic model: skewed normal prior #1
######################################################
skew1 <- skewnormal(xi = c(0, 1),
                    Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                    alpha = c(1, 0), lower =  c(-3, .1), upper = c(3, 2))

res4 <- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = skew1,
              ICA.control = list(rseed = 1366, ncount = 60))
\dontrun{
res4 <- iterate(res4, 700)
plot(res4)
}


######################################################
# Two parameter logistic model: skewed normal prior #2
######################################################
skew2 <- skewnormal(xi = c(0, 1),
                    Omega = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                    alpha = c(-1, 0), lower =  c(-3, .1), upper = c(3, 2))

res5 <- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  4, iter = 1, prior = skew2,
              ICA.control = list(rseed = 1366, ncount = 60))

\dontrun{
res5 <- iterate(res5, 700)
plot(res5)
}

###############################################
# Two parameter logistic model: t student prior
###############################################
# set the prior
stud <- student(mean =  c(0, 1), S   = matrix(c(1, -0.17, -0.17, .5), nrow = 2),
                df = 3, lower =  c(-3, .1), upper = c(3, 2))

res6 <- bayes(formula = ~1/(1 + exp(-b *(x - a))), predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  5, iter = 1, prior = stud,
              ICA.control = list(ncount = 50, rseed = 1366))

\dontrun{
res6 <- iterate(res6, 500)
plot(res6)
}
# not bad, but to find a very accurate designs we increase
# the ncount to 200 and repeat the optimization

res6 <- bayes(formula = ~1/(1 + exp(-b *(x - a))),
              predvars = "x", parvars = c("a", "b"),
              family = binomial(), lx = -3, ux = 3, k =  5, iter = 1, prior = stud,
              ICA.control = list(ncount = 200,  rseed = 1366))

\dontrun{
res6 <- iterate(res6, 1000)
plot(res6)
}


##############################################
# 4-parameter sigmoid Emax model: unform prior
##############################################
lb <- c(4, 11, 100, 5)
ub <- c(8, 15, 130, 9)
res7 <- bayes(formula = ~ theta1 + (theta2 - theta1)*(x^theta4)/(x^theta4 + theta3^theta4),
              predvars = c("x"), parvars = c("theta1", "theta2", "theta3", "theta4"),
              lx = .001, ux = 500, k = 5, iter = 1, prior = uniform(lb, ub),
              ICA.control = list(rseed = 1366, ncount = 60))
\dontrun{
res7 <- iterate(res7, 200)
plot(res7)
}


#######################################################################
# 2-parameter Cox Proportional-Hazards Model for type one cenosred data
#######################################################################
# The Fisher information matrix is available here with name FIM_2par_exp_censor1
# However, we should reparameterize the function to match the standard of the argument 'fimfunc'
myfim <- function(x, w, param)
  FIM_2par_exp_censor1(x = x, w = w, param = param, tcensor = 30)
res8 <- bayes(fimfunc = myfim, lx = 0, ux = 1, k = 4,
              iter = 1, prior = uniform(c(-11, -11), c(11, 11)),
              ICA.control = list(rseed = 1366))
\dontrun{
res8 <- iterate(res8, 200)
plot(res8)
}


#######################################################################
# 2-parameter Cox Proportional-Hazards Model for random cenosred data
#######################################################################
# The Fisher information matrix is available here with name FIM_2par_exp_censor2
# However, we should reparameterize the function to match the standard of the argument 'fimfunc'
myfim <- function(x, w, param)
  FIM_2par_exp_censor2(x = x, w = w, param = param, tcensor = 30)
res9 <- bayes(fimfunc = myfim, lx = 0, ux = 1, k = 2,
              iter = 1, prior = uniform(c(-11, -11), c(11, 11)),
              ICA.control = list(rseed = 1366))
\dontrun{
res9 <- iterate(res9, 200)
plot(res9)
}

#################################
# Weibull model: Uniform prior
################################
# see Dette, H., & Pepelyshev, A. (2008).
# Efficient experimental designs for sigmoidal growth models.
# Journal of statistical planning and inference, 138(1), 2-17.

## See how we fixed a some parameters in Bayesian designs
res10 <- bayes(formula = ~a - b * exp(-lambda * t ^h),
               predvars = c("t"),
               parvars = c("a=1", "b=1", "lambda", "h=1"),
               lx = .00001, ux = 20,
               prior = uniform(.5, 2.5), k = 5, iter = 1,
               ICA.control = list(rseed = 1366), npar = 4)

# you must provide npar here

\dontrun{
res10 <- iterate(res10, 400)
plot(res10)
}

#################################
# Weibull model: Normal prior
################################
norm3 <- normal(mu = 1, sigma = .1, lower = .5, upper = 2.5)
res11 <- bayes(formula = ~a - b * exp(-lambda * t ^h),
               predvars = c("t"),
               parvars = c("a=1", "b=1", "lambda", "h=1"),
               lx = .00001, ux = 20, prior = norm3, k = 4, iter = 1,
               ICA.control = list(rseed = 1366), npar = 4)

\dontrun{
res11 <- iterate(res11, 400)
plot(res11)
}

#################################
# Richards model: Normal prior
#################################
norm4 <- normal(mu = c(1, 1), sigma = matrix(c(.2, 0.1, 0.1, .4), 2, 2),
                lower = c(.4, .4), upper = c(1.6, 1.6))

res12 <- bayes(formula = ~a/(1 + b * exp(-lambda*t))^h,
               predvars = c("t"),
               parvars = c("a=1", "b", "lambda", "h=1"),
               lx = .00001, ux = 10,
               prior = norm4,
               k = 5,
               iter = 1,
               ICA.control = list(rseed = 1366), npar = 4)

\dontrun{
res12 <- iterate(res12, 400)
plot(res12)
}

#################################
# Exponential model: Uniform prior
#################################
res13 <- bayes(formula = ~a + exp(-b*x), predvars = "x",
               parvars = c("a = 1", "b"),
               lx = 0.0001, ux = 1,
               prior = uniform(lower = 1, upper = 20),
               iter = 1, k = 3,
               ICA.control= list(rseed = 100), npar = 2)
\dontrun{
res13 <- iterate(res13, 300)
plot(res13)
}

#################################
# Power logistic model
#################################
# See, Duarte, B. P., & Wong, W. K. (2014).
# A Semidefinite Programming based approach for finding
# Bayesian optimal designs for nonlinear models
uni1 <- uniform(lower = c(-.3, 6, .5), upper = c(.3, 8, 1))
res14 <- bayes(formula = ~1/(1 + exp(-b *(x - a)))^s, predvars = "x",
               parvars = c("a", "b", "s"),
               lx = -1, ux = 1, prior = uni1, k = 5, iter = 1)

\dontrun{
res14 <- iterate(res14, 300)
plot(res14)
}

############################################################################
# A two-variable generalized linear model with a gamma distributed response
############################################################################
lb <- c(.5, 0, 0, 0, 0, 0)
ub <- c(2, 1, 1, 1, 1, 1)
myformula1 <- ~beta0+beta1*x1+beta2*x2+beta3*x1^2+beta4*x2^2+beta5*x1*x2
res15 <- bayes(formula = myformula1,
               predvars = c("x1", "x2"), parvars = paste("beta", 0:5, sep = ""),
               family = Gamma(),
               lx = rep(0, 2), ux = rep(1, 2),
               prior = uniform(lower = lb, upper = ub),
               k = 7,iter = 1, ICA.control = list(rseed = 1366))

\dontrun{
res15 <- iterate(res15, 300)
plot(res15)}

#################################
# Three parameter logistic model
#################################

sigma1 <- matrix(-0.1, nrow = 3, ncol = 3)
diag(sigma1) <- c(.5, .4, .1)
norm5 <- normal(mu =  c(0, 1, .2), sigma = sigma1,
                lower =  c(-3, .1, 0), upper = c(3, 2, .7))

res16 <- bayes(formula = ~ c + (1-c)/(1 + exp(-b *(x - a))), predvars = "x",
               parvars = c("a", "b", "c"),
               family = binomial(), lx = -3, ux = 3,
               k =  4, iter = 1, prior = norm5,
               ICA.control = list(rseed = 1366, ncount = 50),
               crt.bayes.control = list(cubature = list(maxEval = 2500, tol = 1e-4)))

\dontrun{
res16 <- iterate(res16, 500)
plot(res16, sens.bayes.control = list(cubature = list(maxEval = 1000, tol = 1e-4),
                                      optslist = list(maxeval = 100)))
# took 925 second on my system
}


}
